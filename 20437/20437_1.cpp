#include <iostream>
using namespace std;

// 어떤 문자를 정확히 K개를 포함하는 가장 짧은 연속 문자열의 길이를 구한다.
// 0.문제 정의
// 같은 문자를 K개 포함하는 가장 짧은 연속된 문자열의 길이
// 1.문제 풀이
// 첫번째 문자부터 시작해서 모든 문자에 대해서, 각각의 시작 문자와 같은 문자가 K개가 되는 연속된 문자열들 중 최소 길이를 구한다.
// 2.필요 데이터
// 시작 문자와 같은 문자가 K개가 되는 연속된 문자열의 길이 [필요1]
// 시작 문자와 같은 문자가 K개가 되는 연속된 문자열들 중 최소 길이 [필요2]
// 3. 필요 데이터 획득 시점
// 하나의 문자를 시작 문자로 선택하고 시작 문자와 같은 문자가 K개가 될때까지 문자열의 길이 증가 -> 시작 문자와 같은 문자가 K개가 되는 연속된 문자열의 길이를 구한다. [필요1] -> 그 중 최소 길이를 구한다. [필요2]
// 4. 불필요 데이터
// 더 짧은 [필요1-1]을 포함한 [필요1-0] : [필요1-0]시작점~[필요1-1]시작점까지 계산하더라도 [필요1-1]이 가장 짧은 문자열이므로 [필요1-0]시작점~[필요1-1]시작점까지 [필요1]계산 불필요 => [필요1-1]시작점+1부터 다음 [필요1]계산 [불필요1] ([필요1] 모든 문자의 빈도수 저장)
// 이미 확인했던 연속된 문자열의 문자들의 빈도수 다시 구하기 : 이전에 빈도수를 구했기 때문에 다시 구하는건 불필요 => [필요1-0]시작점~[필요1-1]시작점까지의 문자의 빈도만 제거 [불필요2]
// 5. 불필요 데이터획득/제거 시점
// 첫번째 문자를 시작점으로 잡고 끝점을 증가시키며 문자들의 빈도수 저장 -> 빈도수가 K가된 문자를 찾으면 시작점을 빈도수가 K-1까지 증가 [필요1] [불필요1] [불필요2] [필요2] -> 그 중 최소 길이를 구한다. [필요2] (이 과정을 끝점이 문자열 끝에 도달할 때까지 반복)

// 어떤 문자를 정확히 K개를 포함하고, 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 가장 긴 연속 문자열의 길이를 구한다.
// 0. 문제 정의
// 같은 문자를 K개 포함하고 첫 번째와 마지막 글자가 해당 문자인 가장 긴 연속된 문자열의 길이
// 1. 문제 풀이
// 첫번째 문자부터 시작해서 모든 문자에 대해서, 각각의 시작 문자와 같은 문자가 K개가 되는 연속된 문자열들 중 최대 길이를 구한다.
// 2.필요 데이터
// 시작 문자와 같은 문자가 K개가 되는 연속된 문자열의 길이 [필요1]
// 시작 문자와 같은 문자가 K개가 되는 연속된 문자열들 중 최소 길이 [필요2]
// 3. 획득 시점
// 하나의 문자를 시작 문자로 선택하고 시작 문자와 같은 문자가 K개가 될때까지 문자열의 길이 증가 -> 시작 문자와 같은 문자가 K개가 되는 연속된 문자열의 길이를 구한다. [필요1]
// 첫번째 문자부터 시작해서 모든 문자에 대해서, 시작 문자와 같은 문자가 K개가 되는 연속된 문자열의 길이를 구하여 그 중 최대 길이를 구한다. [필요2]
// 4. 불필요 데이터
// [필요1-0]에 포함된 더 짧은 [필요1-1] : [필요1-0] 계산할때 얻어진 [필요1-1]의 시작점 게산 불필요 => [필요1-1]의 시작점 다음 [필요1]계산 제거 [불필요1] ([필요1] 모든 문자의 빈도수와 인덱스 저장)
// 이미 확인했던 연속된 문자열의 문자들의 빈도수 다시 구하기 : 이전에 빈도수를 구했기 때문에 다시 구하는건 불필요 => [필요1-0]시작점 제거 [불필요2]
// 5. 불필요 데이터획득/제거 시점
// 첫번째 문자를 시작점으로 잡고 끝점을 증가시키며 문자들의 빈도수와 시작점을 저장 -> 빈도수가 K가된 문자의 시작점을 금지시키고 (빈도수,시작점)을 감소 [필요1] [불필요1] -> 시작점의 문자의 빈도수가 K를 만족하면 시작점 다음 시작점으로 이동 [필요1] [불필요2]

int freq[26];

const int MX = 10'005;
typedef struct _queue {
    int dat[MX];
    int head, tail;
    void clear() {head = tail = 0;}
    void push(int x) {dat[tail++] = x;};
    void pop() {head++;}
    int front() {return dat[head];}
    int back() {return dat[tail-1];}
    int size() {return (tail-head);}
    bool empty() {return (tail==head);}
}queue;

queue q[26];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int t;
    cin >> t;
    while(t--) {
        string w;
        int k;
        cin >> w >> k;
        int n = w.size();

        fill(freq, freq+26, 0);
        for(int c = 0; c < 26; c++) q[c].clear();

        int min_ans = MX;
        int i = 0;
        for(int j = 0; j < n; j++) {
            int idx = w[j]-'a';
            freq[idx]++;
            while(freq[idx] == k) {
                if(w[i] == w[j]) min_ans = min(min_ans, j-i+1);
                freq[w[i]-'a']--;
                i++;
            }
        }

        int max_ans = 0;
        for(int j = 0; j < n; j++) {
            int idx = w[j]-'a';
            q[idx].push(j);
            if(q[idx].size() == k) {
                max_ans = max(max_ans, j-q[idx].front()+1);
                q[idx].pop();
            }
        }

        if(max_ans) cout << min_ans << ' ' << max_ans << '\n';
        else cout << "-1\n";
    }
}