// https://www.acmicpc.net/problem/2493

// 조건 :
// 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 
// 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다.

// 결과 :
// 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지

// 재정의 :
// 각각의 탑에서 해당 탑의 높이보다 높은 왼쪽에서 가장 가까운 탑의 위치를 구한다.

// 풀이 :
// 각각의 탑에서 현재 탑보다 왼쪽에 위치한 탑들의 높이를 확인하여 현재 탑보다 높고 가장 가까운 탑의 위치를 구한다.

// 필요한 데이터 :
// 현재 탑보다 왼쪽에 위치한 탑들의 높이를 확인 : 현재 탑의 높이와 위치, 이전 탑들의 높이와 위치
// 현재 탑보다 높고 가장 가까운 탑의 위치 : 이전 탑들 중 현재 탑보다 높은 탑들의 높이와 위치 필요 = 이전 탑들 중 현재 탑보다 낮은 탑들은 불필요
// => 모든 이전 탑들의 높이와 위치는 필요 없고, 이전 탑들 중 현재 탑보다 높은 탑들의 높이와 위치 필요

// 데이터 확정/제거 시점 :
// 현재 탑의 높이와 위치 -> 현재 탑의 높이와 위치 입력 시
// 이전 탑들 중 현재 탑보다 높은 탑들의 높이와 위치 -> 현재 탑의 높이와 위치 입력 시 저장된 이전 탑들 중 현재 탑보다 낮은 탑들 제거하고 현재 탑의 위치와 높이 저장
// 현재 탑보다 높고 가장 가까운 탑의 위치 -> 현재 탑의 높이와 위치 입력 시 저장된 이전 탑들 중 현재 탑과 가장 가까운 탑의 위치 확정
// => 현재 탑의 높이와 위치 입력 시 저장된 이전 탑들 중 현재 탑보다 낮은 탑은 제거하고 남은 이전 탑들 중 현재 탑과 가장 가까운 탑의 위치를 확정할 자료구조 유리
// => 탑의 높이와 위치를 기준으로 정렬된 자료구조 = 단조 감소 스택

#include <iostream>
using namespace std;
using pii = pair<int,int>;
#define X first
#define Y second
const int MX = 500'005;
pii dat[MX];
int pos;
void push(pii x) {dat[pos++]=x;}
void pop() {pos--;};
pii top() {return dat[pos-1];}
bool empty() {return pos==0;}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        while(!empty()) {
            if(top().X > x) break;
            pop();
        }
        if(empty()) cout << 0 << ' ';
        else cout << top().Y << ' ';
        push({x,i});
    }
}