// https://www.acmicpc.net/problem/6549
// 조건 : 
// 히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형
// 결과 :
// 히스토그램에서 가장 넓이가 큰 직사각형의 넓이

// 풀이 = O(N^2 x 2) :
// 왼쪽에서 오른쪽으로 각 원소를 순회하면서 각 원소의 높이에서 양쪽으로 순회하며 해당 원소보다 낮은 원소를 탐색하여 최대 너비를 구하여 만들 수 있는 넓이들 중 가장 넓이가 큰 직사각형의 넓이를 구한다. 

// 풀이의 계산 요소 :
// 1. 왼쪽에서 오른쪽으로 각 원소를 순회하면서 각 원소의 높이에서 = 현재 원소와 이전 원소의 높이 확인 -> 높이 확정
// 2. 각 원소의 높이에서 양쪽으로 순회하며 해당 원소보다 낮은 원소를 탐색 = 현재 원소의 높이와 이전 원소와 다음 원소의 높이를 비교하여 첫번째 낮은 원소 탐색시 종료 -> 왼쪽 너비 확정
// 3. 각 원소의 높이에서 양쪽으로 순회하며 해당 원소보다 낮은 원소를 탐색 = 현재 원소의 높이와 이전 원소와 다음 원소의 높이를 비교하여 첫번째 낮은 원소 탐색시 종료 -> 오른쪽 너비 확정

// 풀이의 데이터 요소 :
// 1. 높이 => 현재 원소의 높이 데이터로 확정
// 2. 왼쪽 너비 => 이전 원소의 높이,인덱스 데이터로 확정
// 3. 오른쪽 너비 => 다음 원소의 높이,인덱스 데이터로 확정

// 풀이의 데이터 확정 순서 :
// 1. 현재 원소의 높이,인덱스 확정
// 2. 현재 원소의 이전 원소의 높이,인덱스로 왼쪽 너비 확정
// 3. 현재 원소의 다음 원소의 높이,인덱스로 오른쪽 너비 확정
// => 원소의 높이와 너비 데이터를 확인
// => 1에서 2/3에 필요한 데이터를 모두 확인하고 있으므로, 1의 데이터를 저장하고 2/3의 순서를 1의 순서에 합치면, 2/3에 필요한 계산을 줄인다.

// 풀이의 데이터 확정 순서 병합 :
// 1. 데이터 확정 순서1 + 데이터 확정 순서2
// 계산2의 이전 원소의 높이를 비교하여 첫번째 낮은 원소 탐색하는 계산 
// => 계산1에서 이전 원소들의 높이를 정렬하여 저장 필요
// => 정렬되어 저장된 이전 원소들의 높이를 탐색 
// => 현재 원소보다 높은 이전의 원소들을 탐색하여 현재 원소에 대해서, 계산2 수행 -> 왼쪽 너비 확정
// => 현재 원소보다 높은 이전 원소들은 필요 없음 -> 높은 이전 원소들의 데이터 제거 가능
//
// 2. 데이터 확정 순서1 + 데이터 확정 순서3
// 계산3의 다음 원소의 높이를 비교하여 첫번째 낮은 원소 탐색하는 계산 
// => 계산1에서 이전 원소들의 높이를 정렬하여 저장 필요
// => 현재 원소에 대해서 다음 원소들의 높이는 나중에 알 수 있으므로 계산을 미룸
// => 대신 이전 원소들에 대해서 현재 원소는 다음 원소이므로 미루었던 계산3 수행
// => 정렬되어 저장된 이전 원소들의 높이를 탐색 
// => 현재 원소보다 높은 이전의 원소들을 탐색하여 현재 원소에 대해서, 미뤘던 계산3 수행 -> 오른쪽 너비 확정
// => 현재 원소보다 높은 원소는 필요 없음 -> 높은 이전 원소들의 데이터 제거 가능

// 최종 풀이 = O(N) :
// 왼쪽에서 오른쪽으로 모든 원소를 순회하면서, 각 원소에 대해 현재 원소의 높이와 인덱스를 저장하여, 이전 원소들 높이 중 현재 원소 높이보다 높은 이전 원소들에 대해서 오른쪽 너비를 확정하여 넓이를 구하고 왼쪽 너비를 현재 원소 인덱스에 넘겨주어, 높은 이전 원소들의 데이터는 지운다.

#include <iostream>
using namespace std;
using int64 = long long;
using pii = pair<int64,int64>;
#define X first
#define Y second
const int64 MX = 100'005;
pii dat[MX];
int64 pos;

void push(pii val) {
    dat[pos++] = val;
}
void pop() {
    pos--;
}
int64 empty() {
    return pos == 0;
}
pii top() {
    return dat[pos-1];
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    while(1) {
        int64 n;
        cin >> n;
        if(n == 0) break;
        
        pos = 0;
        int64 ans = 0;
        for(int64 i = 0; i < n; i++) {
            int64 h, j = i;
            cin >> h;
            while(!empty()) {
                if(top().X <= h) break;
                j = top().Y;
                ans = max(ans,top().X * (i - j));
                pop();
            }

            if(!empty() && top().X == h) continue;

            push({h,j});
        }
        while(!empty()) {
            ans = max(ans,top().X * (n - top().Y));
            pop();
        }
        cout << ans << '\n';
    }
}